/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for user profiles,
 * allows public read access to events, and restricts event creation,
 * updates, and deletion to the event creator. Attendees are managed
 * on a per-event basis, with read access granted to event creators and
 * write access restricted to the specific user attending.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles.  Access is restricted to the
 *   user themselves.
 * - /events/{eventId}: Stores event information. Publicly readable, but
 *   only the creator can modify or delete.
 * - /events/{eventId}/attendees/{userId}: Tracks attendees for each event.
 *   Only the user attending can create their attendee document. Event
 *   creators do not have explicit access to this subcollection.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Events are publicly readable, leveraging the "Public Read with Owner-Only
 *   Writes" pattern.
 * - Attendees subcollection writes are only permitted by the user themselves.
 *
 * Denormalization for Authorization:
 * - The `Event` entity contains a `creatorId` field, which is used to
 *   enforce ownership for updates and deletes.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (create) - User with ID 'user123' can create their profile.
     *          request.auth.uid == 'user123'
     * @allow (get, list) - User with ID 'user123' can read their profile.
     *          request.auth.uid == 'user123'
     * @allow (update) - User with ID 'user123' can update their profile.
     *          request.auth.uid == 'user123'
     * @allow (delete) - User with ID 'user123' can delete their profile.
     *          request.auth.uid == 'user123'
     * @deny (create) - User with ID 'user456' cannot create profile for 'user123'.
     *          request.auth.uid == 'user456', resource.data.id == 'user123'
     * @principle Enforces user-ownership: only the authenticated user can
     *            read, create, update, or delete their own profile.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to event documents. Events are publicly
     *              readable, but only the creator can modify them.
     * @path /events/{eventId}
     * @allow (get, list) - Any user can read/list events.
     * @allow (create) - User with ID 'user123' can create an event.
     *          request.auth.uid == 'user123', request.resource.data.creatorId == 'user123'
     * @allow (update) - User with ID 'user123' can update event 'event001' if they are the creator.
     *          request.auth.uid == 'user123', resource.data.creatorId == 'user123'
     * @allow (delete) - User with ID 'user123' can delete event 'event001' if they are the creator.
     *          request.auth.uid == 'user123', resource.data.creatorId == 'user123'
     * @deny (create) - User with ID 'user456' cannot create an event for creator 'user123'.
     *          request.auth.uid == 'user456', request.resource.data.creatorId == 'user123'
     * @deny (update) - User with ID 'user456' cannot update event 'event001' created by 'user123'.
     *          request.auth.uid == 'user456', resource.data.creatorId == 'user123'
     * @principle Implements "Public Read with Owner-Only Writes" pattern.
     *            Enforces document ownership for write operations.
     */
    match /events/{eventId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.creatorId) && request.resource.data.creatorId == resource.data.creatorId;
      allow delete: if isExistingOwner(resource.data.creatorId);
    }

    /**
     * @description Controls access to attendee documents within an event.
     *              Only the user attending can create their attendee document.
     *              Event creators do not have explicit access.
     * @path /events/{eventId}/attendees/{userId}
     * @allow (create) - User 'user123' can create their attendee doc under event 'event001'.
     *          request.auth.uid == 'user123'
     * @allow (get, list) - Any user can read/list attendees for the event.
     * @allow (update) - User 'user123' can update their attendee doc under event 'event001'.
     *          request.auth.uid == 'user123'
     * @allow (delete) - User 'user123' can delete their attendee doc under event 'event001'.
     *          request.auth.uid == 'user123'
     * @deny (create) - User 'user456' cannot create attendee doc for 'user123' under event 'event001'.
     *          request.auth.uid == 'user456'
     * @principle Enforces that only the authenticated user can manage their own
     *            attendee status for a specific event.
     */
    match /events/{eventId}/attendees/{userId} {
      allow get, list: if true;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}