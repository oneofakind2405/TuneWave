/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a mixed security model. User profiles are private and
 * only accessible to the owner. Events are publicly readable, but only the
 * creator can modify or delete them. Event attendees are managed on an
 * event-by-event basis and must be created and deleted by the event creator.
 *
 * Data Structure:
 * - /users/{userId}: Stores individual user profiles.
 * - /events/{eventId}: Stores event information.
 * - /events/{eventId}/attendees/{userId}: Stores a record of who is attending an event
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Anyone can read events, enabling public discovery.
 * - Only the event creator can modify or delete events.
 * - Anyone can list events.
 * - Only the creator can manage attendees of an event.
 *
 * Denormalization for Authorization:
 * The 'Event' entity includes a 'creatorId' field. This field is essential
 * for authorizing updates and deletes, allowing rules to quickly verify
 * ownership without additional reads.
 *
 * Structural Segregation:
 * The application uses top-level collections for both public (events) and private
 * (users) data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (get, list, create, update): If the authenticated user's ID matches the userId.
     * @allow (delete): Never allowed. Users cannot delete their accounts via client-side rules.
     * @deny (get, list, create, update): If the authenticated user's ID does not match the userId.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Controls access to event documents.
     * @path /events/{eventId}
     * @allow (get, list): Allow anyone to get or list events.
     * @allow (create): Allow anyone to create an event, but the creatorId must match the authenticated user's ID.
     * @allow (update, delete): Only the event creator can update or delete an event.
     * @deny (create): If the creatorId does not match the authenticated user's ID.
     * @principle Allows public read access with owner-only writes.
     */
    match /events/{eventId} {
      allow get, list: if true;
      allow create: if request.resource.data.creatorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.creatorId);
      allow delete: if isExistingOwner(resource.data.creatorId);
    }

    /**
     * @description Controls access to attendee documents for an event.
     * @path /events/{eventId}/attendees/{userId}
     * @allow (get, list): Never allowed.
     * @allow (create, update, delete): Only the event creator can manage attendees.
     * @deny (create, update, delete): If the user is not the event creator.
     * @principle Restricts attendee management to the event creator.
     */
    match /events/{eventId}/attendees/{userId} {
        allow get, list: if false;
        allow create: if isEventCreator(eventId);
        allow update: if false;
        allow delete: if isEventCreator(eventId);
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(ownerId) {
      return isSignedIn() && request.auth.uid == ownerId && resource != null;
    }

    function isEventCreator(eventId) {
        return isSignedIn() && get(/databases/$(database)/documents/events/$(eventId)).data.creatorId == request.auth.uid;
    }
  }
}